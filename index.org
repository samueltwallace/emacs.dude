#+TITLE: Sam's Emacs
#+AUTHOR: Samuel Wallace
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="styles.css" />
#+PROPERTY: header-args:emacs-lisp :tangle more-settings.el :comments no :exports code

* Intro

  This config is mainly for writing a mixture of Org and $\LaTeX$ documents. Version controlling is done through Git.

  Note that this creates a /separate/ file for these extra settings; some are loaded with packages, and some are loaded interactively (e.g. ~M-x init-mail-settings~) or in a standard init file (e.g. ~(init-mail-settings)~). This is meant to be used in combination with other settings in a standard ~init.el~, allowing for optional settings or delayed settings.
  
* Startup
** Loading Initial Packages
  
   There are some packages we need to load initially to use throughout:

   #+BEGIN_SRC emacs-lisp
     (setq custom-file "~/.emacs.d/custom.el")
     (load-file custom-file)
   #+END_SRC

** Neofetch Start Screen :bling:

   We make a Neofetch start screen with lots of data for a startup screen (and for that sweet karma).

   #+BEGIN_SRC emacs-lisp
     (defun neofetch () (interactive) (async-shell-command "neofetch" "*Neofetch*"))
     (setq inhibit-startup-screen t)
     (neofetch)
   #+END_SRC

* Modes
** TODO Pure Latex                                                      :TeX:

   We add a function for package load-time settings:
   #+BEGIN_SRC emacs-lisp
     (defun latex-init-settings ()
       (setq TeX-parse-self t)
       (add-to-list 'TeX-command-list
		    '("latexmk lualatex compile" "latexmk -lualatex %s" TeX-run-command nil t))
       (add-to-list 'TeX-command-list
		    '("latexmk lualatex preview" "latexmk -lualatex -pvc -view=none %s" TeX-run-command nil t))
       (add-to-list 'TeX-command-list
		    '("latexindent" "latexindent -w %s" TeX-run-command nil t))
       (setq TeX-view-program-selection '((output-pdf "Okular")))
       (setq cdlatex-math-modify-alist
	     '((98 "\\mathbb" nil t nil nil)
	       (124 "\\abs*" nil t nil nil)
	       (123 "\\set*" nil t nil nil)
	       (102 "\\mathfrak" nil t nil nil)))
       (setq cdlatex-math-symbol-alist
	     '((120 "\\chi" "\\otimes")
	       (62 "\\geq" "\\geqsim" "\\rangle")
	       (60 "\\leq" "\\lesssim" "\\langle")
	       (40 "\\left(")
	       (41 "\\right)")
	       (91 "\\left[")
	       (93 "\\right]"))))
   #+END_SRC

   Let's set a mode hook function:

   #+BEGIN_SRC emacs-lisp
     (defun latex-hook ()
       (cdlatex-mode 1)
       (reftex-mode 1)
       (prettify-symbols-mode 1))
 #+END_SRC
  
   And then we delay loading the package:

   #+BEGIN_SRC emacs-lisp
     (use-package latex
       :defer t
       :ensure auctex
       :config (latex-init-settings))
   #+END_SRC
  
*** CANCELLED make minor mode for wrapping text in LaTeX but not math mode text

Decided I didn't mind... probably not worth the effort.

*** CANCELLED Jump to items and sections

    Let's try to write a function that jumps to the previous thing...

    #+BEGIN_SRC emacs-lisp :tangle no
      (defun latex-last-item () (interactive)
	     (isearch-backward "\\item"))
      (defun latex-last-section () (interactive)
	     (isearch-backward "\\.*section"))
      (defun latex-next-item () (interactive)
	     (isearch "\\item"))
      (defun latex-next-section () (interactive)
	     (isearch "\\.*section"))
    #+END_SRC
   
** Org Settings :Org:

   Several things go on here: we use some minor modes, we set scaling on Latex preview, and then we add CDLaTeX math symbols and commands.
   
   #+BEGIN_SRC emacs-lisp
     (defun latex-in-org-settings ()
       (progn
	 (require 'ox-bibtex)
	 (plist-put org-format-latex-options :scale 2.0)
	 ))
   #+END_SRC

   A small helper function

   #+BEGIN_SRC emacs-lisp
     (defun org-indent-paragraph () (interactive)
	    (org-backward-paragraph)
	    (push-mark)
	    (org-forward-paragraph)
	    (org-indent-region
	     (mark) (point)))
   #+END_SRC

   Let's add some keywords, keybindings, and such:

   #+BEGIN_SRC emacs-lisp
     (defun org-init-settings ()
       (latex-in-org-settings)
       (setq org-agenda-start-on-weekday 0)
       (require 'org-ref-ivy)
       (setq org-ref-insert-link-function 'org-ref-insert-link-hydra/body
      org-ref-insert-cite-function 'org-ref-cite-insert-ivy
      org-ref-insert-label-function 'org-ref-insert-label-link
      org-ref-insert-ref-function 'org-ref-insert-ref-link)
       (require 'org-ref)
       (require 'org-noter)
       (setq org-todo-keywords
	     '((sequence "TODO" "IN PROGRESS" "POSTPONED" "|" "DONE" "CANCELLED"))))
   #+END_SRC

   Let's write an Org-mode-hook function:

   #+BEGIN_SRC emacs-lisp
     (defun org-hook () ()
	    (visual-line-mode)
	    (local-set-key (kbd "C-c ]") 'org-ref-insert-link-hydra)
	    (org-cdlatex-mode))
   #+END_SRC
    
     And we'll add a package load-time function
    
     #+BEGIN_SRC emacs-lisp
       (use-package org
	 :defer t
	 :config (org-init-settings))
   #+END_SRC

** Mu4e Settings

   First, update mail settings:

   #+BEGIN_SRC emacs-lisp
     (defun init-mail-settings () ()
       (setq
	mu4e-get-mail-command "offlineimap -q -o"
	mu4e-update-interval 30000))
   #+END_SRC

   And then we load the package
  
   #+BEGIN_SRC emacs-lisp
     (use-package mu4e
       :load-path  "/usr/share/emacs/site-lisp/mu4e"
       :init (init-mail-settings))
   #+END_SRC
** Hooks

   Now we add some good default hooks:

   #+BEGIN_SRC emacs-lisp
     (add-hook 'mu4e-compose-mode-hook 'turn-off-auto-fill)
     (add-hook 'LaTeX-mode-hook 'latex-hook)
     (add-hook 'org-mode-hook 'org-hook)
   #+END_SRC 
  
* Keybindings and Visuals
** File Manipulation Settings

   Let's make the function for loading settings:

   #+BEGIN_SRC emacs-lisp
     (defun file-manipulation-settings () (interactive)
	    (progn
	      (use-package projectile)
	      (use-package magit)
	      (use-package dired-x)
	      (projectile-mode +1)
	      (setq dired-listing-switches "-ahl")
	      (define-key projectile-mode-map (kbd "C-x p") 'projectile-command-map)
	      (setq dired-guess-shell-alist-user
		    '(("\\.pdf$" "okular *")))))
   #+END_SRC

   Let's also add a command for listing Zotero-stored files for ease:

   #+BEGIN_SRC emacs-lisp
     (defun zotero-store () (interactive)
	    (find-dired "~/Zotero/storage" "-name '*.pdf'"))
   #+END_SRC

** Editing Settings :keys:

   First we'll add some extra editing commands of my own...

   #+BEGIN_SRC emacs-lisp
     (defun smart-kill-word () (interactive)
       (forward-word)
       (kill-word -1))
   #+END_SRC

   This makes conforms to how I do things:

   #+BEGIN_SRC emacs-lisp
     (setq sentence-end-double-space nil)
   #+END_SRC

   Let's load the packages and bind some keys...

   #+BEGIN_SRC emacs-lisp
     (defun editing-settings () (interactive)
	    (use-package counsel)
	    (use-package crux)
	    (ivy-mode +1)
	    (counsel-mode +1)
	    (counsel-projectile-mode +1)
	    (setq bibtex-completion-bibliography '("~/zoterolib.bib"))
	    (global-set-key (kbd "C-x s") 'swiper)
	    (global-set-key (kbd "C-k") 'crux-smart-kill-line)
	    (global-set-key (kbd "M-d") 'smart-kill-word))
   #+END_SRC

   Some useful keybindings...

   #+BEGIN_SRC emacs-lisp
	  (global-set-key (kbd "C-c v v") 'view-mode)
	  (global-set-key (kbd "C-c v f") 'follow-mode)
	  (unbind-key "C-z")
	  (defun machine-uptime () (interactive) (shell-command "uptime"))
	  (defun pacman-update () (interactive) (async-shell-command "sudo pacman -Syu"))
	  (defun get-weather () (interactive)
		 (async-shell-command "curl -s 'https://wttr.in/chicago?0p'" "*wttr.in*" nil))
	  (global-set-key (kbd "C-z p") 'ping)
	  (global-set-key (kbd "C-z t") 'machine-uptime)
	  (global-set-key (kbd "C-z b") 'battery)
	  (global-set-key (kbd "C-z u") 'pacman-update)
	  (global-set-key (kbd "C-z w") 'get-weather)
   #+END_SRC

** Visual/Window settings


   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "M-o") 'ace-window)
     (global-set-key (kbd "C-x b") 'display-buffer)
     (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
     (global-set-key (kbd "M-s m") 'counsel-imenu)
     (global-set-key (kbd "M-s b") 'counsel-ibuffer)
     (global-set-key (kbd "M-z") 'counsel-linux-app)
   #+END_SRC
  
*** IN PROGRESS Try EXWM                                           :bling:wm:

+Decided not to. A fully-afeatured window manager is /probably/ better.+

It's back with a vengeance.

Here we goooo....

#+BEGIN_src emacs-lisp
  (defun exwm-settings ()
    (setq exwm-workspace-number 4)
    (add-hook 'exwm-update-class-hook
	  (lambda ()
	    (unless (or (string-prefix-p "sun-awt-X11-" exwm-instance-name)
			(string= "gimp" exwm-instance-name))
	      (exwm-workspace-rename-buffer exwm-class-name))))
    (add-hook 'exwm-update-title-hook
	      (lambda ()
	    (when (or (not exwm-instance-name)
		      (string-prefix-p "sun-awt-X11-" exwm-instance-name)
		      (string= "gimp" exwm-instance-name))
	      (exwm-workspace-rename-buffer exwm-title))))
    (setq exwm-input-global-keys
	  `((,(kbd "s-SPC") . (lambda (command)
				(interactive (list (read-shell-command "$ ")))
				(start-process-shell-command command nil command)))
	    (,(kbd "s-r") . exwm-reset)
	    (,(kbd "s-o") . exwm-workspace-switch)
	    (,(kbd "s-g") . (lambda () (start-process "slock" nil "slock")))
	    )
	  )
    (exwm-enable)
    )
  (use-package exwm-randr
    :config (progn
	      (setq exwm-randr-workspace-output-plist '(0 "eDP-1" 1 "eDP-1" 2 "HDMI-1" 3 "HDMI-1" 4 "DP-1" 5 "DP-1"))
	      (add-hook 'ewm-randr-screen-change-hook
			(lambda ()
			  (start-process-shell-command
			   "xrandr" nil "xrandr --output HDMI-1 --right-of eDP-1 --auto")))
	      (exwm-randr-enable)))
  (use-package exwm
    :config (exwm-settings))

#+END_src

*** Dynamic Window Layouts

    Here we look to implement two dynamic window layouts, inspired by tiling window managers. This replaces the native window splitting function. 

    We first do an XMonad Tall layout:
    #+BEGIN_SRC emacs-lisp
      (defun xmonad-tree-navigator (tree)
	(if (windowp tree) tree
	  (if (listp tree) (xmonad-tree-navigator (car (last tree)))
	      (error "Encountered a non-list or non window argument"))))

      (defun xmonad-tall (curr-win)
	     (if (one-window-p) (split-window-right)
	       (progn
		 (select-window (xmonad-tree-navigator (car (window-tree))))
		 (split-window-below))))
    #+END_SRC

    And we do a BSPWM one (or a vertical split version):

    #+BEGIN_SRC emacs-lisp
      (defun bsp-tree-navigator (tree)
	(if (windowp tree) tree
	  (if (listp tree) (bsp-tree-navigator (car (last tree)))
	    (error "Encountered a non-list or non-window argument"))))

      (defun bspwm (curr-win)
	     (let ((to-window (bsp-tree-navigator (car (window-tree)))))
	       (progn
		 (select-window to-window)
		 (if (window-combined-p to-window t)
		     (split-window-below)
		   (split-window-right)))))
      
      (defun bspwm-vert (curr-win)
	     (let ((to-window (bsp-tree-navigator (car (window-tree)))))
	       (progn
		 (select-window to-window)
		 (if (window-combined-p to-window t)
		     (split-window-right)
		   (split-window-below)))))
    #+END_SRC

    And now we add a function to switch between layouts:

    #+BEGIN_SRC emacs-lisp
      (setq layout-list '(split-window-sensibly xmonad-tall bspwm bspwm-vert))
      (defun select-window-layout (symbol) (interactive "Slayout: ")
	     (if (member symbol layout-list) (setq split-window-preferred-function symbol)
	       (error "Not a layout in layout-list")))
      (defun current-window-layout () (interactive)
	     (message split-window-preferred-function))
    #+END_SRC

** TODO Minibuffer Frame

Here we create a pop-up minibuffer window to use where ever. The model is this: you should run ~emacsclient --eval '(runner)'~ and the minibuffer menu should appear.

#+BEGIN_SRC emacs-lisp
  (defun runner () (interactive)
	 (setq default-minibuffer-frame (make-frame
					 '((minibuffer . only) (title . "erunner") (left . 0.25) (top . 0.25) (height . 0.5) (width . 0.5))))
	 (setq minibuffer-auto-raise t))
#+END_SRC

Currently needs:
 - [ ] raise frame if already created
 - [X] put windows in main frame (just use ~C-x C-f~ or regular keybindings; just not the usual keybinds)

** Avy

   Let's get warmed up with some simple keybindings for avy:

   #+BEGIN_SRC emacs-lisp
     (use-package avy) 
     (global-set-key (kbd "M-g g") 'avy-goto-char-2)
     (global-set-key (kbd "M-g c") 'avy-goto-char)
     (global-set-key (kbd "M-g M-g") 'avy-goto-line)
     (global-set-key (kbd "M-g f") 'avy-goto-char-in-line)
     (global-set-key (kbd "M-g e") 'avy-goto-end-of-line)
   #+END_SRC

** Shortcut key :keys:

   We make a run key that gives a menu to different programs you might want a glance at.

   #+BEGIN_SRC emacs-lisp
     (defun add-menu-item (key command)
	    (global-set-key (kbd (concat "C-; " key)) command))
     (defun find-init-file () (interactive) (find-file "~/.emacs.d/index.org"))
     (add-menu-item "m" 'mu4e)
     (add-menu-item "i" 'find-init-file)
     (add-menu-item "a" 'org-agenda)
     (add-menu-item "p" 'proced)
     (add-menu-item "b" 'ivy-bibtex)
   #+END_SRC

* External Integrations
** CANCELLED Nyxt Integration                                           :web:

   Here we provide a couple of helper functions for interacting with [[https://nyxt.atlas.engineer][Nyxt]]. I'll explain in a little more detail here.

   We pass Lisp code to the running Nyxt process via shell commands. This requires that ~REMOTE-EXECUTION-P~ must not be ~nil~ (in Nyxt). Once that is done, we can use the following functions to pass arbitrary Lisp code:

   #+BEGIN_SRC emacs-lisp :tangle no
     (defun format-for-nyxt-eval (list)  (shell-quote-argument (format "%S" list))) ;; prepare lisp code to be passed to the shell
     (defun eval-in-nyxt (s-exps)  (call-process "nyxt" nil nil nil (concat "--remote --eval " (format-for-nyxt-eval s-exps))))
   #+END_SRC

   Now we can only do so by elisp code, to prevent mistakes. Now we can use it!

   #+BEGIN_SRC emacs-lisp :tangle no
     (defun set-in-nyxt (variable elisp) (eval-in-nyxt `(setq ,variable (list ,@elisp))))
     (defun eval-region-in-nyxt (start end) (interactive "r") (eval-in-nyxt (read (buffer-substring start end))))
   #+END_SRC

   And if we happen to have the following in our init file for Nyxt (usually in ~$HOME/.config/nyxt/init.lisp~)...

   #+BEGIN_SRC lisp
    
     (ql:quickload :cl-strings)
    
     (defun eval-in-emacs (&rest s-exps)
       "Evaluate S-EXPS with emacsclient."
       (let ((s-exps-string (cl-strings:replace-all
			     (write-to-string
			      `(progn ,@s-exps) :case :downcase)
			     ;; Discard the package prefix.
			     "nyxt::" "")))
	 (format *error-output* "Sending to Emacs:~%~a~%" s-exps-string)
	 (uiop:run-program
	  (list "emacsclient" "--eval" s-exps-string))))
   #+END_SRC

   (Taken directly from [[https://nyxt.atlas.engineer/article/emacs-hacks.org][here]]) then we can use the following function in Emacs:

   #+BEGIN_SRC emacs-lisp :tangle no
     (defun get-nyxt-buffers () (eval-in-nyxt
				 '(eval-in-emacs
				   `(setq nyxt-buffer-list
					  (list ,@(mapcar #'title (buffer-list)))))))
     (defun search-in-nyxt (search-term) (interactive "sSeach in Nyxt:") (eval-in-nyxt
									  `(buffer-load (make-instance 'new-url-query
												       :query ,search-term
												       :engine (first (last (search-engines (current-buffer))))))))
    
   #+END_SRC
** CANCELLED Stumpwm                                                     :wm:

   Let's be able to give commands to Stumpwm. Instead of doing this through slime or Sly, we can do it through ~stumpish~, a command shell for stumpwm. It's in the stumpwm contrib module. We save the path to it and make a function to run Lisp code in Stumpwm:

   #+BEGIN_SRC emacs-lisp :tangle no
     (setq stumpish-path "~/.stumpwm.d/modules/util/stumpish/stumpish")
     (defun eval-in-stumpwm (s-exps) (call-process stumpish-path nil nil nil (format "eval %S" s-exps)))
     (defun eval-in-stumpwm-and-return (s-exps) (read (shell-command-to-string (concat
										stumpish-path " eval "
										(shell-quote-argument (format "%S" s-exps))))))
     (defun eval-region-in-stumpwm (start end) (interactive "r") (eval-in-stumpwm (read (buffer-substring start end))))
   #+END_SRC

   We would also like to be able to pass ELisp to Emacs from Stumpwm:

   #+BEGIN_SRC lisp
     (defun stumpwm-eval-in-emacs (s-exps)
       (run-shell-command (concatenate 'string "emacsclient --eval '" (write-to-string s-exps :case :downcase) "'")))
   #+END_SRC
     
     
     
     And now we're ready to write some helpful interaction commands!

*** CANCELLED Write major mode for editing a buffer for window manager interaction (dired/org-style)

    First we collect the window tree from stumpwm:

    #+BEGIN_SRC emacs-lisp :tangle no
      
      (defun get-stumpwm-desktop () (eval-in-stumpwm-and-return
				     '(progn
					(dump-desktop-to-file "~/.stumpwm.d/.desktop")
					())))
      
      
      
      (defun make-desktop-to-buffer ()
	(let (( window-tree (get-stumpwm-desktop)))
	  '()
	  )) ;;finish
    #+END_SRC

    I am running into some problems with this... Stumpwm doesn't expose enough useful functions to get a full desktop tree. Accessor functions are hidden, slot values as well... Not sure what the solution is. (Maybe try SLIME ?)

    <2021-11-15 Mon> Checking in on this after a while... I'm not using stumpwm so gave up.

** Elfeed                                                               :web:

Let's set up [[https://github.com/skeeto/elfeed][Elfeed]]!

#+BEGIN_src emacs-lisp
  (use-package elfeed
    :ensure t)
  (global-set-key (kbd "C-; e") 'elfeed)
  (setq elfeed-feeds
	'(("http://arxiv.org/rss/math.AP" preprint)
	  ("https://cvgmt.sns.it/papers/rss.xml" preprint)
	  ("http://arxiv.org/rss/cond-mat.soft" preprint)
	  ("https://planet.emacslife.com/atom.xml" emacs)
	  ("https://kbd.news/rss2.php" keyboard)
	  ("https://sachachua.com/blog/feed/" emacs)
	  ))
#+END_src

** Wikipedia Search                                                     :web:

Let's search Wikipedia...

#+BEGIN_src emacs-lisp
  (defun wiki-search (search-term) (interactive "sSearch Wikipedia: ") (browse-url (concat "https://en.wikipedia.org/w/index.php?title=Special%3ASearch&search=" search-term)))
#+END_src

** PDF tools

#+BEGIN_SRC emacs-lisp
  (use-package pdf-tools
    :config (pdf-tools-install))
#+END_SRC

* Resources
** Beginner and General Resources

  Here's a brief list of resources for reading on Emacs...

  - [[https://karthinks.com/software/batteries-included-with-emacs/][Built-in Emacs Features]]
  - [[https://karthinks.com/software/latex-input-for-impatient-scholars/][LaTeX Input]]
  - [[https://sheer.tj/the_way_of_emacs.html][The Way of Emacs]]
  - [[https://github.com/emacs-tw/awesome-emacs][Awesome Emacs GitHub]]
  - [[https://www.masteringemacs.org/][Mastering Emacs]]
  - [[https://sachachua.com/blog/2014/04/emacs-beginner-resources/][Sacha Chua's Beginner Resources]]
  - The keybindings (in Emacs, of course) ~C-h r~ and ~C-h i~

** Other's Configs

Here are some other well-developed configs I've found:

  - [[https://sachachua.com/dotemacs/][Sacha Chua's config]]
  - [[https://github.com/daviwil/emacs-from-scratch][Streamed Config]] A config built entirely on stream, so you can go and watch a video explanation of the config building process
  - [[https://emacs.metaphoric.dev/][Megumacs]] A config I found randomly on GitHub
  - [[https://protesilaos.com/emacs/dotemacs][Prot's config]] A config by an Emacs package writer
