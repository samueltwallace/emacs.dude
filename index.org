#+TITLE: Sam's Emacs
#+AUTHOR: Samuel Wallace
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="styles.css" />
#+PROPERTY: header-args:emacs-lisp :tangle more-settings.el :comments no :exports code

* Intro

  This config is mainly for writing a mixture of Org and $\LaTeX$ documents. Version controlling is done through Git.

  Note that this creates a /separate/ file for these extra settings; some are loaded with packages, and some are loaded interactively (e.g. ~M-x init-mail-settings~) or in a standard init file (e.g. ~(init-mail-settings)~). This is meant to be used in combination with other settings in a standard ~init.el~, allowing for optional settings or delayed settings.
  
* Startup
** Loading Initial Packages
  
   There are some packages we need to load initially to use throughout:

   #+BEGIN_SRC emacs-lisp
     (setq custom-file "~/.emacs.d/custom.el")
     (load-file custom-file)
     (use-package hydra)
   #+END_SRC

** Neofetch Start Screen

   We make a Neofetch start screen with lots of data for a startup screen (and for that sweet karma).

   #+BEGIN_SRC emacs-lisp
     (defun neofetch () (interactive) (async-shell-command "neofetch" "*Neofetch*"))
     (setq inhibit-startup-screen t)
     (neofetch)
   #+END_SRC

* Modes
** Pure Latex

   We add a function for package load-time settings:
   #+BEGIN_SRC emacs-lisp
     (defun latex-init-settings ()
       (defhydra hydra-latex-jump (latex-mode-map "C-x C-j")
	 ("i" latex-next-item "next \\item")
	 ("I" latex-last-item "previous \\item")
	 ("s" latex-next-section "next \\.*section")
	 ("S" latex-last-section "previous \\.*section"))
       (setq TeX-parse-self t)
       (setq cdlatex-math-modify-alist
	     '((98 "\\mathbb" nil t nil nil)))
       (setq cdlatex-math-symbol-alist
	     '((120 "\\chi" "\\otimes")
	       (62 "\\geq" "\\geqsim" "\\rangle")
	       (60 "\\leq" "\\lesssim" "\\langle")
	       (40 "\\left(")
	       (41 "\\right)")
	       (91 "\\left[")
	       (92 "\\right]"))))
   #+END_SRC

   Let's set a mode hook function:

   #+BEGIN_SRC emacs-lisp
     (defun latex-hook ()
       (cdlatex-mode 1)
       (reftex-mode 1)
       (prettify-symbols-mode 1))
 #+END_SRC
  
   And then we delay loading the package:

   #+BEGIN_SRC emacs-lisp
     (use-package latex
       :defer t
       :ensure auctex
       :config (latex-init-settings))
   #+END_SRC
  
*** TODO make minor mode for wrapping text in LaTeX but not math mode text
*** Jump to items and sections

    Let's try to write a function that jumps to the previous thing...

    #+BEGIN_SRC emacs-lisp
      (defun latex-last-item () (interactive)
	     (isearch-backward "\\item"))
      (defun latex-last-section () (interactive)
	     (isearch-backward "\\.*section"))
      (defun latex-next-item () (interactive)
	     (isearch "\\item"))
      (defun latex-next-section () (interactive)
	     (isearch "\\.*section"))
    #+END_SRC
   
** Org Settings

   Several things go on here: we use some minor modes, we set scaling on Latex preview, and then we add CDLaTeX math symbols and commands.
   #+BEGIN_SRC emacs-lisp
     (defun latex-in-org-settings ()
       (progn
	 (require 'ox-bibtex)
	 (plist-put org-format-latex-options :scale 2.0)
	 ))
   #+END_SRC

   A small helper function

   #+BEGIN_SRC emacs-lisp
     (defun org-indent-paragraph () (interactive)
	    (org-backward-paragraph)
	    (push-mark)
	    (org-forward-paragraph)
	    (org-indent-region
	     (mark) (point)))
   #+END_SRC

   Let's add some keywords, keybindings, and such:

   #+BEGIN_SRC emacs-lisp
     (defun org-init-settings ()
       (latex-in-org-settings)
       (defhydra hydra-org-commands (org-mode-map "C-x h")
	 ("<Up>" 'org-previous-visible-heading "prev heading")
	 ("<Down>" 'org-next-visible-heading "next heading")
	 ("<tab>" 'org-indent-paragraph "indent paragraph"))
       (setq org-agenda-start-on-weekday 0)
       (setq org-todo-keywords
	     '((sequence "TODO" "IN PROGRESS" "POSTPONED" "|" "DONE" "CANCELLED"))))
   #+END_SRC

   Let's write an Org-mode-hook function:

   #+BEGIN_SRC emacs-lisp
     (defun org-hook () ()
	    (visual-line-mode)
	    (org-cdlatex-mode))
   #+END_SRC

   And a hydra for keybindings:

   #+BEGIN_SRC emacs-lisp
   #+END_SRC
    
     And we'll add a package load-time function
    
     #+BEGIN_SRC emacs-lisp
       (use-package org
	 :defer t
	 :config (org-init-settings))
   #+END_SRC

** Mu4e Settings

   First, update mail settings:

   #+BEGIN_SRC emacs-lisp
     (defun init-mail-settings () ()
       (setq
	mu4e-get-mail-command "offlineimap -q -o"
	mu4e-update-interval 3000))
   #+END_SRC

   And then we load the package
  
   #+BEGIN_SRC emacs-lisp
     (use-package mu4e
       :load-path  "/usr/share/emacs/site-lisp/mu4e"
       :init (init-mail-settings))
   #+END_SRC
** Hooks

   Now we add some good default hooks:

   #+BEGIN_SRC emacs-lisp
     (add-hook 'mu4e-compose-mode-hook 'turn-off-auto-fill)
     (add-hook 'LaTeX-mode-hook 'latex-hook)
     (add-hook 'org-mode-hook 'org-hook)
   #+END_SRC 
  
* Keybindings and Visuals
** File Manipulation Settings

   Let's make the function for loading settings:

   #+BEGIN_SRC emacs-lisp
     (defun file-manipulation-settings () (interactive)
	    (progn
	      (use-package projectile)
	      (use-package magit)
	      (use-package dired-x)
	      (projectile-mode +1)
	      (setq dired-listing-switches "-ahl")
	      (define-key projectile-mode-map (kbd "C-x p") 'projectile-command-map)
	      (setq dired-guess-shell-alist-user
		    '(("\\.pdf$" "zathura *")))))
   #+END_SRC

   Let's also add a command for listing Zotero-stored files for ease:

   #+BEGIN_SRC emacs-lisp
     (defun zotero-store () (interactive)
	    (find-dired "~/Zotero/storage" "-name '*.pdf'"))
   #+END_SRC

** Editing Settings

   First we'll add some extra editing commands of my own...

   #+BEGIN_SRC emacs-lisp
     (defun smart-kill-word () (interactive)
       (forward-word)
       (kill-word -1))
   #+END_SRC
  
   Let's load the packages and bind some keys...

   #+BEGIN_SRC emacs-lisp
     (defun editing-settings () (interactive)
	    (use-package counsel)
	    (use-package crux)
	    (ivy-mode +1)
	    (global-set-key (kbd "C-x s") 'swiper)
	    (global-set-key (kbd "C-k") 'crux-smart-kill-line)
	    (global-set-key (kbd "M-d") 'smart-kill-word)
	    (defhydra hydra-editing (global-map "M-.")
	      ("h" backward-char "back char")
	      ("j" forward-line "forward line")
	      ("k" previous-line "prev line")
	      ("l" forward-char "forward char")
	      ("o" open-line "open line")
	      ("RET" newline "newline")
	      ("/" swiper "swiper")
	      ("f" avy-goto-char-in-line "jump char")
	      ("w" forward-word "forward word")
	      ("b" backward-word "back word")
	      ("J" join-line "join line")
	      ("K" kill-region "kill region")
	      ("r" kill-rectangle "kill rect")
	      ("R" string-rectangle "replace rect")
	      ("SPC" set-mark-command "set mark")
	    ))
   #+END_SRC

   Some useful keybindings...

   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "C-c v v") 'view-mode)
     (global-set-key (kbd "C-c v f") 'follow-mode)
     (unbind-key "C-z")
     (defun machine-uptime () (interactive) (shell-command "uptime"))
     (defun pacman-update () (interactive) (async-shell-command "sudo pacman -Syu"))
     (global-set-key (kbd "C-z p") 'ping)
     (global-set-key (kbd "C-z t") 'machine-uptime)
     (global-set-key (kbd "C-z b") 'battery)
     (global-set-key (kbd "C-z u") 'pacman-update)
   #+END_SRC

** Visual/Window settings


   #+BEGIN_SRC emacs-lisp
     (require 'windmove)
     (defhydra hydra-window-manip (global-map "C-x o")
       ("H" shrink-window-horizontally "shrink horizontally")
       ("L" enlarge-window-horizontally "grow horizontally")
       ("J" enlarge-window "grow vertically")
       ("0" delete-window "delete window")
       ("1" delete-other-windows "fullscreen this one")
       ("2" split-window-below "split below")
       ("3" split-window-right "split right")
       ("h" windmove-left "move left")
       ("j" windmove-down "move down")
       ("k" windmove-up "move up")
       ("=" balance-windows "equal sizing")
       ("L" windmove-right "move right")
       ("o" other-window "cycle-move")
       ("b" display-buffer "select buffer")
       ("c" clone-indirect-buffer-other-window "clone buffer")
       )
   #+END_SRC
  
*** TODO Try EXWM (?)

*** Dynamic Window Layouts

    Here we look to implement two dynamic window layouts, inspired by tiling window managers. This replaces the native window splitting function. 

    We first do an XMonad Tall layout:
    #+BEGIN_SRC emacs-lisp
	   (defun xmonad-tree-navigator (tree)
	     (if (windowp tree) tree
	       (if (listp tree) (xmonad-tree-navigator (car (last tree)))
		   (error "Encountered a non-list or non window argument"))))
	  
	   (defun xmonad-tall (curr-win)
		  (if (one-window-p) (split-window-right)
		    (progn
		      (select-window (xmonad-tree-navigator (car (window-tree))))
		      (split-window-below))))
    #+END_SRC

    And we do a BSPWM one:

    #+BEGIN_SRC emacs-lisp
      (defun bsp-tree-navigator (tree)
	(if (windowp tree) tree
	  (if (listp tree) (bsp-tree-navigator (car (last tree)))
	    (error "Encountered a non-list or non-window argument"))))
     
      (defun bspwm (curr-win)
	     (let ((to-window (bsp-tree-navigator (car (window-tree)))))
	       (progn
		 (select-window to-window)
		 (if (window-combined-p to-window t)
		     (split-window-below)
		   (split-window-right)))))
    #+END_SRC

    And now we add a function to switch between layouts:

    #+BEGIN_SRC emacs-lisp
      (setq layout-list '(split-window-sensibly xmonad-tall bspwm))
      (defun select-window-layout (symbol) (interactive "Slayout: ")
	     (if (member symbol layout-list) (setq split-window-preferred-function symbol)
	       (error "Not a layout in layout-list")))
      (defun current-window-layout () (interactive)
	     (message split-window-preferred-function))
    #+END_SRC

** Avy

   Let's get warmed up with some simple keybindings for avy:

   #+BEGIN_SRC emacs-lisp
     (use-package avy)
     (global-set-key (kbd "M-g g") 'avy-goto-char-2)
     (global-set-key (kbd "M-g M-g") 'avy-goto-line)
     (global-set-key (kbd "M-g k") 'avy-kill-region)
     (global-set-key (kbd "M-g t") 'avy-move-region)
     (global-set-key (kbd "M-g w") 'avy-copy-region)
   #+END_SRC

** Shortcut key

   We make a run key that gives a menu to different programs you might want a glance at.

   #+BEGIN_SRC emacs-lisp
     (defun add-menu-item (key command)
	    (global-set-key (kbd (concat "C-; " key)) command))
     (defun find-init-file () (interactive) (find-file "~/.emacs.d/index.org"))
     (add-menu-item "m" 'mu4e)
     (add-menu-item "i" 'find-init-file)
     (add-menu-item "a" 'org-agenda)
     (add-menu-item "s" 'search-in-nyxt)
     (add-menu-item "p" 'proced)
   #+END_SRC

* External Integrations
** Nyxt Integration

   Here we provide a couple of helper functions for interacting with [[https://nyxt.atlas.engineer][Nyxt]]. I'll explain in a little more detail here.

   We pass Lisp code to the running Nyxt process via shell commands. This requires that ~REMOTE-EXECUTION-P~ must not be ~nil~ (in Nyxt). Once that is done, we can use the following functions to pass arbitrary Lisp code:

   #+BEGIN_SRC emacs-lisp
     (defun format-for-nyxt-eval (list)  (shell-quote-argument (format "%S" list))) ;; prepare lisp code to be passed to the shell
     (defun eval-in-nyxt (s-exps)  (call-process "nyxt" nil nil nil (concat "--remote --eval " (format-for-nyxt-eval s-exps))))
   #+END_SRC

   Now we can only do so by elisp code, to prevent mistakes. Now we can use it!

   #+BEGIN_SRC emacs-lisp
     (defun set-in-nyxt (variable elisp) (eval-in-nyxt `(setq ,variable (list ,@elisp))))
     (defun eval-region-in-nyxt (start end) (interactive "r") (eval-in-nyxt (read (buffer-substring start end))))
   #+END_SRC

   And if we happen to have the following in our init file for Nyxt (usually in ~$HOME/.config/nyxt/init.lisp~)...

   #+BEGIN_SRC lisp
    
     (ql:quickload :cl-strings)
    
     (defun eval-in-emacs (&rest s-exps)
       "Evaluate S-EXPS with emacsclient."
       (let ((s-exps-string (cl-strings:replace-all
			     (write-to-string
			      `(progn ,@s-exps) :case :downcase)
			     ;; Discard the package prefix.
			     "nyxt::" "")))
	 (format *error-output* "Sending to Emacs:~%~a~%" s-exps-string)
	 (uiop:run-program
	  (list "emacsclient" "--eval" s-exps-string))))
   #+END_SRC

   (Taken directly from [[https://nyxt.atlas.engineer/article/emacs-hacks.org][here]]) then we can use the following function in Emacs:

   #+BEGIN_SRC emacs-lisp
     (defun get-nyxt-buffers () (eval-in-nyxt
				 '(eval-in-emacs
				   `(setq nyxt-buffer-list
					  (list ,@(mapcar #'title (buffer-list)))))))
     (defun search-in-nyxt (search-term) (interactive "sSeach in Nyxt:") (eval-in-nyxt
									  `(buffer-load (make-instance 'new-url-query
												       :query ,search-term
												       :engine (first (last (search-engines (current-buffer))))))))
    
   #+END_SRC
** Stumpwm

   Let's be able to give commands to Stumpwm. Instead of doing this through slime or Sly, we can do it through ~stumpish~, a command shell for stumpwm. It's in the stumpwm contrib module. We save the path to it and make a function to run Lisp code in Stumpwm:

   #+BEGIN_SRC emacs-lisp
     (setq stumpish-path "~/.stumpwm.d/modules/util/stumpish/stumpish")
     (defun eval-in-stumpwm (s-exps) (call-process stumpish-path nil nil nil (format "eval %S" s-exps)))
     (defun eval-in-stumpwm-and-return (s-exps) (read (shell-command-to-string (concat
										stumpish-path " eval "
										(shell-quote-argument (format "%S" s-exps))))))
     (defun eval-region-in-stumpwm (start end) (interactive "r") (eval-in-stumpwm (read (buffer-substring start end))))
   #+END_SRC

   We would also like to be able to pass ELisp to Emacs from Stumpwm:

   #+BEGIN_SRC lisp
     (defun stumpwm-eval-in-emacs (s-exps)
       (run-shell-command (concatenate 'string "emacsclient --eval '" (write-to-string s-exps :case :downcase) "'")))
   #+END_SRC
     
     
     
     And now we're ready to write some helpful interaction commands!

*** TODO Write major mode for editing a buffer for window manager interaction (dired/org-style)

    First we collect the window tree from stumpwm:

    #+BEGIN_SRC emacs-lisp :tangle no
      
      (defun get-stumpwm-desktop () (eval-in-stumpwm-and-return
				     '(progn
					(dump-desktop-to-file "~/.stumpwm.d/.desktop")
					())))
      
      
      
      (defun make-desktop-to-buffer ()
	(let (( window-tree (get-stumpwm-desktop)))
	  '()
	  )) ;;finish
    #+END_SRC

    I am running into some problems with this... Stumpwm doesn't expose enough useful functions to get a full desktop tree. Accessor functions are hidden, slot values as well... Not sure what the solution is. (Maybe try SLIME ?)

* Resources

  Here's a brief list of resources for reading on Emacs...

  - [[https://karthinks.com/software/batteries-included-with-emacs/][Built-in Emacs Features]]
  - [[https://karthinks.com/software/latex-input-for-impatient-scholars/][LaTeX Input]]
  - [[https://sheer.tj/the_way_of_emacs.html][The Way of Emacs]]
  - [[https://github.com/emacs-tw/awesome-emacs][Awesome Emacs GitHub]]
  - [[https://www.masteringemacs.org/][Mastering Emacs]]
  - The keybindings (in Emacs, of course) ~C-h r~ and ~C-h i~
